# MemoryTools Node.js Client

A Node.js client for interacting with the MemoryTools database via its TLS-based binary protocol.

---

## ðŸš€ Installation

To integrate the client into your Node.js project, use npm:

```bash
npm install memory-tools-client
```

---

## ðŸ“– Usage & Connection

### Initialization

The `MemoryToolsClient` class allows you to connect to your server and **authenticate**. Providing user credentials is highly recommended for most operations.

```javascript
import MemoryToolsClient from "memory-tools-client";
import path from "node:path";

// Server Configuration
const DB_HOST = "127.0.0.1";
const DB_PORT = 5876;
const DB_USER = "admin";
const DB_PASS = "adminpass";

// TLS Connection Options

// Option 1: Secure connection with certificate verification (RECOMMENDED)
// You need the .crt file generated by the server.
const SERVER_CERT_PATH = path.join(process.cwd(), "certificates", "server.crt");
const client = new MemoryToolsClient(
  DB_HOST,
  DB_PORT,
  DB_USER,
  DB_PASS,
  SERVER_CERT_PATH,
  true // rejectUnauthorized: true (default)
);

// Option 2: Secure connection using system's CAs
// Uses the OS's default CAs. Fails if the server uses a self-signed cert
// not trusted by the OS.
const clientSystemCA = new MemoryToolsClient(
  DB_HOST,
  DB_PORT,
  DB_USER,
  DB_PASS,
  null, // Uses system CAs
  true
);

// Option 3: Encrypted connection without verification (NOT FOR PRODUCTION)
// Useful for local development with self-signed certificates.
const clientInsecure = new MemoryToolsClient(
  DB_HOST,
  DB_PORT,
  DB_USER,
  DB_PASS,
  null,
  false // rejectUnauthorized: false (ignores verification)
);

async function runExample() {
  try {
    await client.connect();
    console.log(
      `Connected and authenticated as: ${client.getAuthenticatedUsername()}`
    );

    // Perform your database operations here
    const collections = await client.collectionList();
    console.log("Available collections:", collections.names);
  } catch (error) {
    console.error("Connection or operation error:", error.message);
  } finally {
    // Ensure the connection is closed when you're done
    client.close();
    console.log("Connection closed.");
  }
}

runExample();
```

---

## âš¡ API Reference

### Connection and Session Methods

#### `constructor(host, port, username?, password?, serverCertPath?, rejectUnauthorized?)`

Creates a new client instance.

- **`host`** (`string`): The IP address or hostname of the server.
- **`port`** (`number`): The TLS port of the server.
- **`username`** (`string | null`): Username for authentication.
- **`password`** (`string | null`): Password for authentication.
- **`serverCertPath`** (`string | null`): Path to the CA certificate that signed your server's certificate. If `null`, uses the OS's default CAs.
- **`rejectUnauthorized`** (`boolean`): Defaults to `true`. If `false`, the connection will be established even if the server's certificate cannot be verified. **Use with extreme caution.**

#### `connect(): Promise<tls.TLSSocket>`

Establishes the TLS connection and authenticates the session if credentials were provided.

#### `isSessionAuthenticated(): boolean`

Returns `true` if the current client session is authenticated.

#### `getAuthenticatedUsername(): string | null`

Returns the username of the authenticated user or `null`.

#### `close(): void`

Closes the underlying socket connection.

---

### Main Store Operations

#### `set<T = any>(key: string, value: T, ttlSeconds?: number): Promise<string>`

Stores a key-value pair in the main store. The `value` is automatically JSON-serialized.

- **`ttlSeconds`** (`number`, optional): Time-to-live in seconds. `0` means no expiration.

#### `get<T = any>(key: string): Promise<{ found: boolean, message: string, value: T | null }>`

Retrieves a value from the main store. The value is automatically parsed from JSON.

---

### Collection Operations

#### `collectionCreate(collectionName: string): Promise<string>`

Creates a new collection.

#### `collectionDelete(collectionName: string): Promise<string>`

Deletes an entire collection and all its items.

#### `collectionList(): Promise<{ message: string, names: string[] }>`

Lists the names of all available collections.

---

### Index Operations

#### `collectionIndexCreate(collectionName: string, fieldName: string): Promise<string>`

Creates an index on a specific field within a collection to speed up filtering operations.

```javascript
await client.collectionIndexCreate("users", "email");
console.log("Index on field 'email' created for collection 'users'.");
```

#### `collectionIndexDelete(collectionName: string, fieldName: string): Promise<string>`

Deletes an index from a collection.

```javascript
await client.collectionIndexDelete("users", "email");
console.log("Index on 'email' deleted.");
```

#### `collectionIndexList<T = string[]>(collectionName: string): Promise<T>`

Lists all indexed fields for a specific collection.

```javascript
const indexes = await client.collectionIndexList("users");
console.log("Indexes for 'users':", indexes); // e.g., ['email', 'city']
```

---

### Collection Item Operations

#### `collectionItemSet<T = any>(collectionName: string, key: string, value: T, ttlSeconds?: number): Promise<string>`

Stores an item within a specific collection.

#### `collectionItemSetMany<T = any>(collectionName:string, values: T[]): Promise<string>`

Stores multiple items in a collection from an array of objects. It's recommended that each object have an `_id` field to be used as its key.

#### `collectionItemGet<T = any>(collectionName: string, key: string): Promise<{ found: boolean, message: string, value: T | null }>`

Retrieves a specific item from a collection.

#### `collectionItemDelete(collectionName: string, key: string): Promise<string>`

Deletes an item from a collection by its key.

#### `collectionItemDeleteMany(collectionName: string, keys: string[]): Promise<string>`

Deletes multiple items from a collection using an array of keys.

#### `collectionItemList<T = any>(collectionName: string): Promise<{ message: string, items: { [key: string]: T } }>`

Lists all items (key-value pairs) within a specific collection.

---

### Query Operations

#### `collectionQuery<T = any>(collectionName: string, query: Query): Promise<T>`

Executes a complex query on a specific collection.

- **`query`** (`Query`): An object defining the filter, order, limit, etc.

The `Query` interface is defined as:

```typescript
interface Query {
  filter?: { [key: string]: any };
  orderBy?: OrderByClause[];
  limit?: number;
  offset?: number;
  count?: boolean;
  aggregations?: { [key: string]: Aggregation };
  groupBy?: string[];
  having?: { [key: string]: any };
  distinct?: string;
}

interface OrderByClause {
  field: string;
  direction: "asc" | "desc";
}

interface Aggregation {
  func: "sum" | "avg" | "min" | "max" | "count";
  field: string;
}
```

**Example:**

```javascript
// Get users older than 25, ordered by name
const results = await client.collectionQuery("users", {
  filter: { field: "age", op: ">", value: 25 },
  orderBy: [{ field: "name", direction: "asc" }],
});
console.log("Query results:", results);
```

---

## ðŸ”’ Security Considerations

- **TLS is Essential**: Always use TLS to ensure data is encrypted in transit.
- **Certificate Verification**: For production, always set `rejectUnauthorized` to `true` (the default) and provide a `serverCertPath` to your CA certificate. This prevents man-in-the-middle attacks.
- **`rejectUnauthorized: false`**: Only use this for local development or testing in a controlled, isolated environment.
- **Authentication**: Always provide user credentials to the constructor to ensure operations are authorized.
- **Credential Management**: Avoid hardcoding credentials. Use environment variables or a secret management service.

---

## Support the Project!

Hello! I'm the developer behind **Memory Tools**. This is an open-source project.

I've dedicated a lot of time and effort to this project, and with your support, I can continue to maintain it, add new features, and make it better for everyone.

---

### How You Can Help

Every contribution, no matter the size, is a great help and is enormously appreciated. If you would like to support the continued development of this project, you can make a donation via PayPal.

You can donate directly to my PayPal account by clicking the link below:

**[Click here to donate](https://paypal.me/AdonayB?locale.x=es_XC&country.x=VE)**

---

### Other Ways to Contribute

If you can't donate, don't worry! You can still help in other ways:

- **Share the project:** Talk about it on social media or with your friends.
- **Report bugs:** If you find a problem, open an issue on GitHub.
- **Contribute code:** If you have coding skills, you can help improve the code.
  Thank you for your support!
